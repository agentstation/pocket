# API Reference

This document provides a comprehensive reference for the Pocket API. For auto-generated API documentation from source code, see the embedded section below.

## Overview

Pocket provides a clean, idiomatic Go API for building decision graphs and workflows. The API is designed around interfaces for maximum flexibility and composability.

<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# pocket

```go
import "github.com/agentstation/pocket"
```

Package pocket provides a minimalist framework for building LLM workflows using composable nodes in a directed graph structure.

Key features:

- Small, composable interfaces
- Type\-safe operations with generics
- Built\-in concurrency patterns
- Functional options for configuration
- Zero external dependencies in core

Basic usage:

```
// Create a simple processor
greet := pocket.ProcessorFunc(func(ctx context.Context, input any) (any, error) {
	name := input.(string)
	return fmt.Sprintf("Hello, %s!", name), nil
})

// Create a node
node := pocket.NewNode[any, any]("greeter", greet)

// Create and run a graph
store := pocket.NewStore()
graph := pocket.NewGraph(node, store)
result, err := graph.Run(context.Background(), "World")
```

Building complex graphs:

```
// Use the builder API
builder := pocket.NewBuilder(store).
	Add(pocket.NewNode[any, any]("fetch", fetchData)).
	Add(pocket.NewNode[any, any]("process", processData)).
	Add(pocket.NewNode[any, any]("save", saveData)).
	Connect("fetch", "success", "process").
	Connect("process", "success", "save").
	Start("fetch")

graph, err := builder.Build()
```

Concurrent patterns:

```
// Fan-out processing
results, err := pocket.FanOut(ctx, processNode, store, items)

// Pipeline
result, err := pocket.Pipeline(ctx, nodes, store, input)

// Concurrent execution
results, err := pocket.RunConcurrent(ctx, nodes, store)
```

Type\-safe operations:

```
// Create a typed store
userStore := pocket.NewTypedStore[User](store)

// Type-safe get/set
user, exists, err := userStore.Get(ctx, "user:123")
err = userStore.Set(ctx, "user:123", newUser)
```

Package pocket provides a minimalist framework for building LLM workflows using composable nodes in a directed graph structure with Prep/Exec/Post lifecycle.

Type Safety: The framework provides three levels of type safety for workflow validation:

- Compile\-time: Generic node creation with NewNode\[In, Out\] enforces type consistency within nodes. The Go compiler checks function signatures when using the generic WithExec, WithPrep, etc. with typed nodes.

- Initialization\-time: ValidateFlow checks type compatibility across the entire workflow graph before execution begins. This catches type mismatches between connected nodes.

- Runtime: Type assertions in lifecycle functions ensure data integrity during execution. These are minimized when using typed nodes.

The goal is to verify type safety of the workflow graph as early as possible, catching errors before any workflow execution begins.

<details><summary>Example (Lifecycle)</summary>
<p>

Example\_lifecycle demonstrates the full Prep/Exec/Post lifecycle.

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/agentstation/pocket"
)

func main() {
	// Create a node that uses all three steps
	processor := pocket.NewNode[any, any]("processor",
		pocket.WithPrep(func(ctx context.Context, store pocket.StoreReader, input any) (any, error) {
			// Prepare: validate and transform input
			data := input.(map[string]int)
			if len(data) == 0 {
				return nil, fmt.Errorf("empty data")
			}
			return data, nil
		}),
		pocket.WithExec(func(ctx context.Context, data any) (any, error) {
			// Execute: calculate sum
			m := data.(map[string]int)
			sum := 0
			for _, v := range m {
				sum += v
			}
			return sum, nil
		}),
		pocket.WithPost(func(ctx context.Context, store pocket.StoreWriter, input, data, sum any) (any, string, error) {
			// Post: decide routing based on result
			total := sum.(int)
			if total > 100 {
				return fmt.Sprintf("High total: %d", total), "high", nil
			}
			return fmt.Sprintf("Low total: %d", total), "low", nil
		}),
	)

	store := pocket.NewStore()
	graph := pocket.NewGraph(processor, store)

	result, err := graph.Run(context.Background(), map[string]int{
		"a": 10,
		"b": 20,
		"c": 30,
	})
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(result)
}
```

#### Output

```
Low total: 60
```

</p>
</details>

## Index

- [Variables](<#variables>)
- [func FanOut\[T any\]\(ctx context.Context, node Node, store Store, items \[\]T\) \(\[\]any, error\)](<#FanOut>)
- [func Pipeline\(ctx context.Context, nodes \[\]Node, store Store, input any\) \(any, error\)](<#Pipeline>)
- [func ResetDefaults\(\)](<#ResetDefaults>)
- [func RunConcurrent\(ctx context.Context, nodes \[\]Node, store Store, inputs \[\]any\) \(\[\]any, error\)](<#RunConcurrent>)
- [func SetDefaultExec\(fn ExecFunc\)](<#SetDefaultExec>)
- [func SetDefaultPost\(fn PostFunc\)](<#SetDefaultPost>)
- [func SetDefaultPrep\(fn PrepFunc\)](<#SetDefaultPrep>)
- [func SetDefaults\(opts ...Option\)](<#SetDefaults>)
- [func ValidateGraph\(start Node\) error](<#ValidateGraph>)
- [type Builder](<#Builder>)
  - [func NewBuilder\(store Store\) \*Builder](<#NewBuilder>)
  - [func \(b \*Builder\) Add\(node Node\) \*Builder](<#Builder.Add>)
  - [func \(b \*Builder\) Build\(\) \(\*Graph, error\)](<#Builder.Build>)
  - [func \(b \*Builder\) Connect\(from, action, to string\) \*Builder](<#Builder.Connect>)
  - [func \(b \*Builder\) Start\(name string\) \*Builder](<#Builder.Start>)
  - [func \(b \*Builder\) WithOptions\(opts ...GraphOption\) \*Builder](<#Builder.WithOptions>)
- [type ExecFunc](<#ExecFunc>)
- [type FanIn](<#FanIn>)
  - [func NewFanIn\(combine func\(\[\]any\) \(any, error\), sources ...Node\) \*FanIn](<#NewFanIn>)
  - [func \(f \*FanIn\) Run\(ctx context.Context, store Store\) \(any, error\)](<#FanIn.Run>)
- [type Graph](<#Graph>)
  - [func NewGraph\(start Node, store Store, opts ...GraphOption\) \*Graph](<#NewGraph>)
  - [func \(g \*Graph\) AsNode\(name string\) Node](<#Graph.AsNode>)
  - [func \(g \*Graph\) Run\(ctx context.Context, input any\) \(output any, err error\)](<#Graph.Run>)
- [type GraphOption](<#GraphOption>)
  - [func WithLogger\(logger Logger\) GraphOption](<#WithLogger>)
  - [func WithTracer\(tracer Tracer\) GraphOption](<#WithTracer>)
- [type Logger](<#Logger>)
- [type Node](<#Node>)
  - [func Default\(n, next Node\) Node](<#Default>)
  - [func NewNode\[In, Out any\]\(name string, opts ...Option\) Node](<#NewNode>)
- [type Option](<#Option>)
  - [func WithErrorHandler\(handler func\(error\)\) Option](<#WithErrorHandler>)
  - [func WithExec\[In, Out any\]\(fn func\(ctx context.Context, input In\) \(Out, error\)\) Option](<#WithExec>)
  - [func WithFallback\[In, Out any\]\(fn func\(ctx context.Context, input In, err error\) \(Out, error\)\) Option](<#WithFallback>)
  - [func WithOnComplete\(fn func\(ctx context.Context, store StoreWriter\)\) Option](<#WithOnComplete>)
  - [func WithOnFailure\(fn func\(ctx context.Context, store StoreWriter, err error\)\) Option](<#WithOnFailure>)
  - [func WithOnSuccess\[Out any\]\(fn func\(ctx context.Context, store StoreWriter, output Out\)\) Option](<#WithOnSuccess>)
  - [func WithPost\[In, Out any\]\(fn func\(ctx context.Context, store StoreWriter, input In, prepResult any, execResult Out\) \(Out, string, error\)\) Option](<#WithPost>)
  - [func WithPrep\[In any\]\(fn func\(ctx context.Context, store StoreReader, input In\) \(any, error\)\) Option](<#WithPrep>)
  - [func WithRetry\(maxRetries int, delay time.Duration\) Option](<#WithRetry>)
  - [func WithTimeout\(timeout time.Duration\) Option](<#WithTimeout>)
- [type PostFunc](<#PostFunc>)
- [type PrepFunc](<#PrepFunc>)
- [type Store](<#Store>)
  - [func NewStore\(opts ...StoreOption\) Store](<#NewStore>)
- [type StoreOption](<#StoreOption>)
  - [func WithEvictionCallback\(fn func\(key string, value any\)\) StoreOption](<#WithEvictionCallback>)
  - [func WithMaxEntries\(maxEntries int\) StoreOption](<#WithMaxEntries>)
  - [func WithTTL\(ttl time.Duration\) StoreOption](<#WithTTL>)
- [type StoreReader](<#StoreReader>)
- [type StoreWriter](<#StoreWriter>)
- [type Tracer](<#Tracer>)
- [type TypedStore](<#TypedStore>)
  - [func NewTypedStore\[T any\]\(store Store\) TypedStore\[T\]](<#NewTypedStore>)


## Variables

<a name="ErrNoStartNode"></a>Common errors.

```go
var (
    // ErrNoStartNode is returned when a graph has no start node defined.
    ErrNoStartNode = errors.New("pocket: no start node defined")

    // ErrNodeNotFound is returned when a referenced node doesn't exist.
    ErrNodeNotFound = errors.New("pocket: node not found")

    // ErrInvalidInput is returned when input type doesn't match expected type.
    ErrInvalidInput = errors.New("pocket: invalid input type")
)
```

<a name="FanOut"></a>
## func [FanOut](<https://github.com/agentstation/pocket/blob/master/builder.go#L138>)

```go
func FanOut[T any](ctx context.Context, node Node, store Store, items []T) ([]any, error)
```

FanOut executes a node for each input item concurrently.

<details><summary>Example</summary>
<p>

ExampleFanOut demonstrates parallel processing of items.

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/agentstation/pocket"
)

func main() {
	// Create a processor that simulates work
	processor := pocket.NewNode[any, any]("process",
		pocket.WithExec(func(ctx context.Context, input any) (any, error) {
			num := input.(int)
			return num * num, nil
		}),
	)

	store := pocket.NewStore()
	items := []int{1, 2, 3, 4, 5}

	// Process items concurrently
	results, err := pocket.FanOut(context.Background(), processor, store, items)
	if err != nil {
		log.Fatal(err)
	}

	// Results maintain order
	for i, result := range results {
		fmt.Printf("%d -> %v\n", items[i], result)
	}
}
```

#### Output

```
1 -> 1
2 -> 4
3 -> 9
4 -> 16
5 -> 25
```

</p>
</details>

<a name="Pipeline"></a>
## func [Pipeline](<https://github.com/agentstation/pocket/blob/master/builder.go#L122>)

```go
func Pipeline(ctx context.Context, nodes []Node, store Store, input any) (any, error)
```

Pipeline executes nodes sequentially, passing output to input.

<details><summary>Example</summary>
<p>

ExamplePipeline demonstrates sequential processing.

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/agentstation/pocket"
)

func main() {
	store := pocket.NewStore()

	// Create a pipeline of transformations
	double := pocket.NewNode[any, any]("double",
		pocket.WithExec(func(ctx context.Context, input any) (any, error) {
			return input.(int) * 2, nil
		}),
	)

	addTen := pocket.NewNode[any, any]("addTen",
		pocket.WithExec(func(ctx context.Context, input any) (any, error) {
			return input.(int) + 10, nil
		}),
	)

	toString := pocket.NewNode[any, any]("toString",
		pocket.WithExec(func(ctx context.Context, input any) (any, error) {
			return fmt.Sprintf("Result: %d", input.(int)), nil
		}),
	)

	nodes := []pocket.Node{double, addTen, toString}

	result, err := pocket.Pipeline(context.Background(), nodes, store, 5)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(result)
}
```

#### Output

```
Result: 20
```

</p>
</details>

<a name="ResetDefaults"></a>
## func [ResetDefaults](<https://github.com/agentstation/pocket/blob/master/defaults.go#L124>)

```go
func ResetDefaults()
```

ResetDefaults resets all global defaults to their initial values.

<a name="RunConcurrent"></a>
## func [RunConcurrent](<https://github.com/agentstation/pocket/blob/master/builder.go#L76>)

```go
func RunConcurrent(ctx context.Context, nodes []Node, store Store, inputs []any) ([]any, error)
```

RunConcurrent executes multiple nodes concurrently.

<a name="SetDefaultExec"></a>
## func [SetDefaultExec](<https://github.com/agentstation/pocket/blob/master/defaults.go#L90>)

```go
func SetDefaultExec(fn ExecFunc)
```

SetDefaultExec sets the global default exec function.

<a name="SetDefaultPost"></a>
## func [SetDefaultPost](<https://github.com/agentstation/pocket/blob/master/defaults.go#L97>)

```go
func SetDefaultPost(fn PostFunc)
```

SetDefaultPost sets the global default post function.

<a name="SetDefaultPrep"></a>
## func [SetDefaultPrep](<https://github.com/agentstation/pocket/blob/master/defaults.go#L83>)

```go
func SetDefaultPrep(fn PrepFunc)
```

SetDefaultPrep sets the global default prep function.

<a name="SetDefaults"></a>
## func [SetDefaults](<https://github.com/agentstation/pocket/blob/master/defaults.go#L38>)

```go
func SetDefaults(opts ...Option)
```

SetDefaults configures global defaults for all nodes.

<a name="ValidateGraph"></a>
## func [ValidateGraph](<https://github.com/agentstation/pocket/blob/master/pocket.go#L651>)

```go
func ValidateGraph(start Node) error
```

ValidateGraph provides initialization\-time type safety by validating the entire workflow graph.

Type validation process:

1. Traverses the graph starting from the given node using depth\-first search
2. For each connection between nodes, verifies type compatibility: \- Source node's OutputType must be assignable to target node's InputType \- Interface satisfaction is checked \(e.g., concrete type implements interface\) \- Untyped nodes \(InputType/OutputType = nil\) are skipped but successors are validated
3. Returns detailed error messages identifying the exact type mismatch location

This is a critical part of the type safety system, catching errors before any workflow execution begins. It complements compile\-time checks by validating the connections between nodes.

Type compatibility rules:

- Exact type match: string \-\> string ✓
- Interface satisfaction: ConcreteType \-\> Interface \(if implements\) ✓
- Any type: any \-\> ConcreteType ✓ \(but loses compile\-time safety\)
- Assignability: Uses Go's reflect.Type.AssignableTo for compatibility

Example:

```
// Build your workflow
validator := NewNode[User, ValidationResult]("validator", ...)
processor := NewNode[ValidationResult, Response]("processor", ...)
validator.Connect("valid", processor)

// Validate before execution - catches type mismatches early
if err := ValidateGraph(validator); err != nil {
    // Error: "type mismatch: node 'validator' outputs ValidationResult
    //         but node 'wrongNode' expects User (via action 'valid')"
    log.Fatal(err)
}

// Safe to execute - types are verified
graph := NewGraph(validator, store)
result, err := graph.Run(ctx, user)
```

<a name="Builder"></a>
## type [Builder](<https://github.com/agentstation/pocket/blob/master/builder.go#L12-L17>)

Builder provides a fluent API for constructing graphs.

```go
type Builder struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>

ExampleBuilder demonstrates the fluent builder API.

```go
store := pocket.NewStore()

// Define nodes with lifecycle
validate := pocket.NewNode[any, any]("validate",
	pocket.WithPrep(func(ctx context.Context, store pocket.StoreReader, input any) (any, error) {
		email, ok := input.(string)
		if !ok {
			return nil, fmt.Errorf("expected string")
		}
		return email, nil
	}),
	pocket.WithExec(func(ctx context.Context, email any) (any, error) {
		if !strings.Contains(email.(string), "@") {
			return nil, fmt.Errorf("invalid email")
		}
		return email, nil
	}),
	pocket.WithPost(func(ctx context.Context, store pocket.StoreWriter, input, prep, result any) (any, string, error) {
		return result, defaultRoute, nil
	}),
)

normalize := pocket.NewNode[any, any]("normalize",
	pocket.WithExec(func(ctx context.Context, input any) (any, error) {
		email := input.(string)
		return strings.ToLower(strings.TrimSpace(email)), nil
	}),
)

// Build the graph
graph, err := pocket.NewBuilder(store).
	Add(validate).
	Add(normalize).
	Connect("validate", "default", "normalize").
	Start("validate").
	Build()

if err != nil {
	log.Fatal(err)
}

result, err := graph.Run(context.Background(), "  USER@EXAMPLE.COM  ")
if err != nil {
	log.Fatal(err)
}

fmt.Println(result)
// Output: user@example.com
```

#### Output

```
user@example.com
```

</p>
</details>

<a name="NewBuilder"></a>
### func [NewBuilder](<https://github.com/agentstation/pocket/blob/master/builder.go#L20>)

```go
func NewBuilder(store Store) *Builder
```

NewBuilder creates a new graph builder.

<a name="Builder.Add"></a>
### func \(\*Builder\) [Add](<https://github.com/agentstation/pocket/blob/master/builder.go#L28>)

```go
func (b *Builder) Add(node Node) *Builder
```

Add registers a node in the graph.

<a name="Builder.Build"></a>
### func \(\*Builder\) [Build](<https://github.com/agentstation/pocket/blob/master/builder.go#L67>)

```go
func (b *Builder) Build() (*Graph, error)
```

Build creates the graph.

<a name="Builder.Connect"></a>
### func \(\*Builder\) [Connect](<https://github.com/agentstation/pocket/blob/master/builder.go#L45>)

```go
func (b *Builder) Connect(from, action, to string) *Builder
```

Connect creates a connection between nodes.

<a name="Builder.Start"></a>
### func \(\*Builder\) [Start](<https://github.com/agentstation/pocket/blob/master/builder.go#L37>)

```go
func (b *Builder) Start(name string) *Builder
```

Start sets the starting node.

<a name="Builder.WithOptions"></a>
### func \(\*Builder\) [WithOptions](<https://github.com/agentstation/pocket/blob/master/builder.go#L61>)

```go
func (b *Builder) WithOptions(opts ...GraphOption) *Builder
```

WithOptions adds graph options.

<a name="ExecFunc"></a>
## type [ExecFunc](<https://github.com/agentstation/pocket/blob/master/pocket.go#L46>)

ExecFunc performs the main processing logic without store access.

```go
type ExecFunc func(ctx context.Context, prepResult any) (execResult any, err error)
```

<a name="FanIn"></a>
## type [FanIn](<https://github.com/agentstation/pocket/blob/master/builder.go#L170-L173>)

FanIn collects results from multiple sources.

```go
type FanIn struct {
    // contains filtered or unexported fields
}
```

<a name="NewFanIn"></a>
### func [NewFanIn](<https://github.com/agentstation/pocket/blob/master/builder.go#L176>)

```go
func NewFanIn(combine func([]any) (any, error), sources ...Node) *FanIn
```

NewFanIn creates a fan\-in pattern.

<a name="FanIn.Run"></a>
### func \(\*FanIn\) [Run](<https://github.com/agentstation/pocket/blob/master/builder.go#L184>)

```go
func (f *FanIn) Run(ctx context.Context, store Store) (any, error)
```

Run executes the fan\-in pattern.

<a name="Graph"></a>
## type [Graph](<https://github.com/agentstation/pocket/blob/master/pocket.go#L516-L518>)

Graph is the public handle to a graph for backward compatibility.

```go
type Graph struct {
    // contains filtered or unexported fields
}
```

<a name="NewGraph"></a>
### func [NewGraph](<https://github.com/agentstation/pocket/blob/master/pocket.go#L594>)

```go
func NewGraph(start Node, store Store, opts ...GraphOption) *Graph
```

NewGraph creates a new graph starting from the given node.

<a name="Graph.AsNode"></a>
### func \(\*Graph\) [AsNode](<https://github.com/agentstation/pocket/blob/master/pocket.go#L908>)

```go
func (g *Graph) AsNode(name string) Node
```

AsNode returns the graph as a Node interface. Since graph already implements Node, we just return it. This method exists for backward compatibility.

<a name="Graph.Run"></a>
### func \(\*Graph\) [Run](<https://github.com/agentstation/pocket/blob/master/pocket.go#L716>)

```go
func (g *Graph) Run(ctx context.Context, input any) (output any, err error)
```

Run executes the graph with the given input.

<a name="GraphOption"></a>
## type [GraphOption](<https://github.com/agentstation/pocket/blob/master/pocket.go#L527>)

GraphOption configures a Graph.

```go
type GraphOption func(*graphOptions)
```

<a name="WithLogger"></a>
### func [WithLogger](<https://github.com/agentstation/pocket/blob/master/pocket.go#L530>)

```go
func WithLogger(logger Logger) GraphOption
```

WithLogger adds logging to the graph.

<a name="WithTracer"></a>
### func [WithTracer](<https://github.com/agentstation/pocket/blob/master/pocket.go#L537>)

```go
func WithTracer(tracer Tracer) GraphOption
```

WithTracer adds distributed tracing.

<a name="Logger"></a>
## type [Logger](<https://github.com/agentstation/pocket/blob/master/pocket.go#L917-L921>)

Logger provides structured logging.

```go
type Logger interface {
    Debug(ctx context.Context, msg string, keysAndValues ...any)
    Info(ctx context.Context, msg string, keysAndValues ...any)
    Error(ctx context.Context, msg string, keysAndValues ...any)
}
```

<a name="Node"></a>
## type [Node](<https://github.com/agentstation/pocket/blob/master/pocket.go#L84-L102>)

Node is the core interface for all execution units in a workflow. Both simple nodes and graphs implement this interface.

```go
type Node interface {
    // Name returns the node's identifier.
    Name() string

    // Lifecycle methods for the Prep/Exec/Post pattern.
    Prep(ctx context.Context, store StoreReader, input any) (prepResult any, err error)
    Exec(ctx context.Context, prepResult any) (execResult any, err error)
    Post(ctx context.Context, store StoreWriter, input, prepResult, execResult any) (output any, next string, err error)

    // Connect adds a successor node for the given action.
    Connect(action string, next Node) Node

    // Successors returns all connected nodes.
    Successors() map[string]Node

    // Type information for validation (optional).
    InputType() reflect.Type
    OutputType() reflect.Type
}
```

<details><summary>Example</summary>
<p>

ExampleNode demonstrates using the Prep/Exec/Post lifecycle.

```go
// Create a node with lifecycle steps
uppercase := pocket.NewNode[any, any]("uppercase",
	pocket.WithPrep(func(ctx context.Context, store pocket.StoreReader, input any) (any, error) {
		// Validate input is a string
		text, ok := input.(string)
		if !ok {
			return nil, fmt.Errorf("expected string, got %T", input)
		}
		return text, nil
	}),
	pocket.WithExec(func(ctx context.Context, text any) (any, error) {
		// Transform to uppercase
		return strings.ToUpper(text.(string)), nil
	}),
	pocket.WithPost(func(ctx context.Context, store pocket.StoreWriter, input, text, result any) (any, string, error) {
		// Return result and routing
		return result, doneRoute, nil
	}),
)

store := pocket.NewStore()
graph := pocket.NewGraph(uppercase, store)

result, err := graph.Run(context.Background(), "hello world")
if err != nil {
	log.Fatal(err)
}

fmt.Println(result)
// Output: HELLO WORLD
```

#### Output

```
HELLO WORLD
```

</p>
</details>

<details><summary>Example (Routing)</summary>
<p>

ExampleNode\_routing demonstrates conditional routing between nodes.

```go
package main

import (
	"context"
	"fmt"

	"github.com/agentstation/pocket"
)

func main() {
	store := pocket.NewStore()

	// Router node that checks input
	router := pocket.NewNode[any, any]("router",
		pocket.WithExec(func(ctx context.Context, input any) (any, error) {
			return input, nil
		}),
		pocket.WithPost(func(ctx context.Context, store pocket.StoreWriter, input, prep, result any) (any, string, error) {
			value := result.(int)
			if value > 100 {
				return result, "large", nil
			}
			return result, "small", nil
		}),
	)

	// Handler nodes
	largeHandler := pocket.NewNode[any, any]("large",
		pocket.WithExec(func(ctx context.Context, input any) (any, error) {
			return fmt.Sprintf("Large number: %v", input), nil
		}),
	)

	smallHandler := pocket.NewNode[any, any]("small",
		pocket.WithExec(func(ctx context.Context, input any) (any, error) {
			return fmt.Sprintf("Small number: %v", input), nil
		}),
	)

	// Connect nodes
	router.Connect("large", largeHandler)
	router.Connect("small", smallHandler)

	// Run with different inputs
	graph := pocket.NewGraph(router, store)

	result1, _ := graph.Run(context.Background(), 50)
	result2, _ := graph.Run(context.Background(), 150)

	fmt.Println(result1)
	fmt.Println(result2)
}
```

#### Output

```
Small number: 50
Large number: 150
```

</p>
</details>

<a name="Default"></a>
### func [Default](<https://github.com/agentstation/pocket/blob/master/pocket.go#L502>)

```go
func Default(n, next Node) Node
```

Default is a helper function to connect to the default next node.

<a name="NewNode"></a>
### func [NewNode](<https://github.com/agentstation/pocket/blob/master/pocket.go#L481>)

```go
func NewNode[In, Out any](name string, opts ...Option) Node
```

NewNode creates a new node with optional compile\-time type safety.

Type parameters:

- In: The expected input type for this node \(use 'any' for dynamic typing\)
- Out: The output type this node produces \(use 'any' for dynamic typing\)

Type safety mechanism:

1. Compile\-time: When In/Out are not 'any', the node stores type information for validation. Using generic options like WithExec, WithPrep ensures function signatures match the declared types at compile time.

2. Initialization\-time: Call ValidateFlow on your start node to verify the entire workflow graph has compatible types between connected nodes.

3. Runtime: When using regular options \(WithExec, WithPrep\) with typed nodes, the framework automatically wraps functions to ensure type safety.

Examples:

```
// Typed node - enables full type checking across the workflow
validator := NewNode[User, ValidationResult]("validator",
    WithExec(func(ctx context.Context, store Store, user User) (ValidationResult, error) {
        // Compile-time type safety - no casting needed
        return ValidationResult{Valid: true}, nil
    }),
)

// Untyped node - no compile-time checks (explicit [any, any] encourages adding types)
processor := NewNode[any, any]("processor",
    WithExec(func(ctx context.Context, store Store, input any) (any, error) {
        return processData(input), nil
    }),
)
```

<a name="Option"></a>
## type [Option](<https://github.com/agentstation/pocket/blob/master/pocket.go#L148>)

Option configures a Node.

```go
type Option func(*nodeOptions)
```

<a name="WithErrorHandler"></a>
### func [WithErrorHandler](<https://github.com/agentstation/pocket/blob/master/pocket.go#L262>)

```go
func WithErrorHandler(handler func(error)) Option
```

WithErrorHandler sets a custom error handler.

<a name="WithExec"></a>
### func [WithExec](<https://github.com/agentstation/pocket/blob/master/pocket.go#L177>)

```go
func WithExec[In, Out any](fn func(ctx context.Context, input In) (Out, error)) Option
```

WithExec sets the execution function with type safety. The types In and Out should match the node's types when used with NewNode\[In, Out\]. For dynamic typing, use WithExec\[any, any\]. Exec functions do not have store access to enforce pure business logic.

<a name="WithFallback"></a>
### func [WithFallback](<https://github.com/agentstation/pocket/blob/master/pocket.go#L272>)

```go
func WithFallback[In, Out any](fn func(ctx context.Context, input In, err error) (Out, error)) Option
```

WithFallback adds a fallback function that runs if the exec step fails. The types In and Out should match the node's types when used with NewNode\[In, Out\]. For dynamic typing, use WithFallback\[any, any\]. Like exec functions, fallback functions do not have store access.

<a name="WithOnComplete"></a>
### func [WithOnComplete](<https://github.com/agentstation/pocket/blob/master/pocket.go#L319>)

```go
func WithOnComplete(fn func(ctx context.Context, store StoreWriter)) Option
```

WithOnComplete sets a cleanup hook that always runs after execution. The store parameter provides full read\-write access for cleanup operations.

<a name="WithOnFailure"></a>
### func [WithOnFailure](<https://github.com/agentstation/pocket/blob/master/pocket.go#L311>)

```go
func WithOnFailure(fn func(ctx context.Context, store StoreWriter, err error)) Option
```

WithOnFailure sets a cleanup hook that runs after failed execution. The store parameter provides full read\-write access for cleanup operations.

<a name="WithOnSuccess"></a>
### func [WithOnSuccess](<https://github.com/agentstation/pocket/blob/master/pocket.go#L295>)

```go
func WithOnSuccess[Out any](fn func(ctx context.Context, store StoreWriter, output Out)) Option
```

WithOnSuccess sets a cleanup hook that runs after successful execution. The type Out should match the node's output type when used with NewNode\[In, Out\]. For dynamic typing, use WithOnSuccess\[any\]. The store parameter provides full read\-write access for cleanup operations.

<a name="WithPost"></a>
### func [WithPost](<https://github.com/agentstation/pocket/blob/master/pocket.go#L210>)

```go
func WithPost[In, Out any](fn func(ctx context.Context, store StoreWriter, input In, prepResult any, execResult Out) (Out, string, error)) Option
```

WithPost sets the post\-processing function with type safety. The types In and Out should match the node's types when used with NewNode\[In, Out\]. Post functions have access to all step results and determine routing. For dynamic typing, use WithPost\[any, any\]. The store parameter provides full read\-write access for state mutations.

<a name="WithPrep"></a>
### func [WithPrep](<https://github.com/agentstation/pocket/blob/master/pocket.go#L154>)

```go
func WithPrep[In any](fn func(ctx context.Context, store StoreReader, input In) (any, error)) Option
```

WithPrep sets the preparation function with type safety. The input type In should match the node's input type when used with NewNode\[In, Out\]. For dynamic typing, use WithPrep\[any\]. The store parameter provides read\-only access to enforce Prep step semantics.

<a name="WithRetry"></a>
### func [WithRetry](<https://github.com/agentstation/pocket/blob/master/pocket.go#L247>)

```go
func WithRetry(maxRetries int, delay time.Duration) Option
```

WithRetry configures retry behavior.

<details><summary>Example</summary>
<p>

ExampleWithRetry demonstrates retry configuration.

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/agentstation/pocket"
)

func main() {
	attempts := 0

	// Create a node that fails twice before succeeding
	flaky := pocket.NewNode[any, any]("flaky",
		pocket.WithExec(func(ctx context.Context, input any) (any, error) {
			attempts++
			if attempts < 3 {
				return nil, fmt.Errorf("temporary failure %d", attempts)
			}
			return "success", nil
		}),
		pocket.WithRetry(2, 10*time.Millisecond), // Retry up to 2 times
	)

	store := pocket.NewStore()
	graph := pocket.NewGraph(flaky, store)

	result, err := graph.Run(context.Background(), nil)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Result after %d attempts: %v\n", attempts, result)
}
```

#### Output

```
Result after 3 attempts: success
```

</p>
</details>

<a name="WithTimeout"></a>
### func [WithTimeout](<https://github.com/agentstation/pocket/blob/master/pocket.go#L255>)

```go
func WithTimeout(timeout time.Duration) Option
```

WithTimeout sets execution timeout.

<a name="PostFunc"></a>
## type [PostFunc](<https://github.com/agentstation/pocket/blob/master/pocket.go#L49>)

PostFunc processes results and determines routing with full store access.

```go
type PostFunc func(ctx context.Context, store StoreWriter, input, prepResult, execResult any) (output any, next string, err error)
```

<a name="PrepFunc"></a>
## type [PrepFunc](<https://github.com/agentstation/pocket/blob/master/pocket.go#L43>)

PrepFunc prepares data before execution with read\-only store access.

```go
type PrepFunc func(ctx context.Context, store StoreReader, input any) (prepResult any, err error)
```

<a name="Store"></a>
## type [Store](<https://github.com/agentstation/pocket/blob/master/pocket.go#L68-L80>)

Store provides thread\-safe storage for shared state.

```go
type Store interface {
    // Get retrieves a value by key.
    Get(ctx context.Context, key string) (value any, exists bool)

    // Set stores a value with the given key.
    Set(ctx context.Context, key string, value any) error

    // Delete removes a key from the store.
    Delete(ctx context.Context, key string) error

    // Scope returns a new store with the given prefix.
    Scope(prefix string) Store
}
```

<a name="NewStore"></a>
### func [NewStore](<https://github.com/agentstation/pocket/blob/master/store.go#L63>)

```go
func NewStore(opts ...StoreOption) Store
```

NewStore creates a new thread\-safe store with optional configuration.

<a name="StoreOption"></a>
## type [StoreOption](<https://github.com/agentstation/pocket/blob/master/store.go#L12>)

StoreOption configures a store.

```go
type StoreOption func(*storeConfig)
```

<a name="WithEvictionCallback"></a>
### func [WithEvictionCallback](<https://github.com/agentstation/pocket/blob/master/store.go#L38>)

```go
func WithEvictionCallback(fn func(key string, value any)) StoreOption
```

WithEvictionCallback sets a callback for when entries are evicted.

<a name="WithMaxEntries"></a>
### func [WithMaxEntries](<https://github.com/agentstation/pocket/blob/master/store.go#L23>)

```go
func WithMaxEntries(maxEntries int) StoreOption
```

WithMaxEntries sets the maximum number of entries in the store. When exceeded, the least recently used entry is evicted.

<a name="WithTTL"></a>
### func [WithTTL](<https://github.com/agentstation/pocket/blob/master/store.go#L31>)

```go
func WithTTL(ttl time.Duration) StoreOption
```

WithTTL sets the time\-to\-live for entries. Entries older than the TTL are automatically removed.

<a name="StoreReader"></a>
## type [StoreReader](<https://github.com/agentstation/pocket/blob/master/pocket.go#L53-L59>)

StoreReader provides read\-only access to the store. Used in the Prep step to enforce read\-only semantics.

```go
type StoreReader interface {
    // Get retrieves a value by key.
    Get(ctx context.Context, key string) (value any, exists bool)

    // Scope returns a new store with the given prefix.
    Scope(prefix string) Store
}
```

<a name="StoreWriter"></a>
## type [StoreWriter](<https://github.com/agentstation/pocket/blob/master/pocket.go#L63-L65>)

StoreWriter provides full read\-write access to the store. Used in the Post step for state mutations.

```go
type StoreWriter interface {
    Store
}
```

<a name="Tracer"></a>
## type [Tracer](<https://github.com/agentstation/pocket/blob/master/pocket.go#L924-L926>)

Tracer provides distributed tracing capabilities.

```go
type Tracer interface {
    StartSpan(ctx context.Context, name string) (context.Context, func())
}
```

<a name="TypedStore"></a>
## type [TypedStore](<https://github.com/agentstation/pocket/blob/master/store.go#L195-L199>)

TypedStore provides type\-safe storage operations.

```go
type TypedStore[T any] interface {
    Get(ctx context.Context, key string) (T, bool, error)
    Set(ctx context.Context, key string, value T) error
    Delete(ctx context.Context, key string) error
}
```

<details><summary>Example</summary>
<p>

ExampleTypedStore demonstrates type\-safe storage.

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/agentstation/pocket"
)

func main() {
	type User struct {
		ID   string
		Name string
	}

	// Create a typed store
	store := pocket.NewStore()
	userStore := pocket.NewTypedStore[User](store)

	ctx := context.Background()

	// Store a user
	user := User{ID: "123", Name: "Alice"}
	err := userStore.Set(ctx, "user:123", user)
	if err != nil {
		log.Fatal(err)
	}

	// Retrieve with type safety
	retrieved, exists, err := userStore.Get(ctx, "user:123")
	if err != nil {
		log.Fatal(err)
	}

	if exists {
		fmt.Printf("Found user: %+v\n", retrieved)
	}
}
```

#### Output

```
Found user: {ID:123 Name:Alice}
```

</p>
</details>

<a name="NewTypedStore"></a>
### func [NewTypedStore](<https://github.com/agentstation/pocket/blob/master/store.go#L202>)

```go
func NewTypedStore[T any](store Store) TypedStore[T]
```

NewTypedStore creates a type\-safe wrapper around a Store.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->

## Core Types

### Node Interface

The fundamental building block of Pocket workflows.

```go
type Node interface {
    // Name returns the node's identifier
    Name() string
    
    // Prep phase: Read-only store access, input validation
    Prep(ctx context.Context, store StoreReader, input any) (prepResult any, err error)
    
    // Exec phase: Pure computation, no store access
    Exec(ctx context.Context, prepResult any) (execResult any, err error)
    
    // Post phase: Full store access, routing decisions
    Post(ctx context.Context, store StoreWriter, input, prepResult, execResult any) (output any, next string, err error)
    
    // Connect adds a successor node for the given action
    Connect(action string, next Node) Node
    
    // Successors returns all connected nodes
    Successors() map[string]Node
    
    // InputType returns the expected input type (for validation)
    InputType() reflect.Type
    
    // OutputType returns the output type (for validation)
    OutputType() reflect.Type
}
```

### Graph

Orchestrates node execution in a workflow.

```go
type Graph struct {
    // Internal fields
}

// NewGraph creates a new graph with a start node and store
func NewGraph(start Node, store Store) *Graph

// Run executes the workflow with the given input
func (g *Graph) Run(ctx context.Context, input any) (output any, err error)

// AsNode returns the graph as a Node (for composition)
func (g *Graph) AsNode(name string) Node

// Graph implements Node interface
func (g *Graph) Name() string
func (g *Graph) Prep(ctx context.Context, store StoreReader, input any) (any, error)
func (g *Graph) Exec(ctx context.Context, prepResult any) (any, error)
func (g *Graph) Post(ctx context.Context, store StoreWriter, input, prep, exec any) (any, string, error)
func (g *Graph) Connect(action string, next Node) Node
func (g *Graph) Successors() map[string]Node
func (g *Graph) InputType() reflect.Type
func (g *Graph) OutputType() reflect.Type
```

### Store

Thread-safe storage for workflow state.

```go
type Store interface {
    // Get retrieves a value by key
    Get(ctx context.Context, key string) (value any, exists bool)
    
    // Set stores a value with the given key
    Set(ctx context.Context, key string, value any) error
    
    // Delete removes a key from the store
    Delete(ctx context.Context, key string) error
    
    // Scope returns a new store with the given prefix
    Scope(prefix string) Store
}

// StoreReader provides read-only access (used in Prep)
type StoreReader interface {
    Get(ctx context.Context, key string) (value any, exists bool)
    Scope(prefix string) Store
}

// StoreWriter provides full access (used in Post)
type StoreWriter interface {
    Store
}
```

## Node Creation

### NewNode

Creates a new node with generic type parameters.

```go
func NewNode[In, Out any](name string, opts ...NodeOption) Node
```

**Parameters:**
- `name`: Unique identifier for the node
- `opts`: Configuration options (see NodeOption)

**Type Parameters:**
- `In`: Expected input type
- `Out`: Output type

**Example:**
```go
node := pocket.NewNode[User, ProcessedUser]("process-user",
    pocket.WithExec(func(ctx context.Context, user User) (ProcessedUser, error) {
        return processUser(user), nil
    }),
)
```

### NodeOption Functions

#### WithPrep

Sets the Prep phase function.

```go
func WithPrep(fn PrepFunc) NodeOption
func WithPrep[In any](fn func(context.Context, StoreReader, In) (any, error)) NodeOption
```

**Example:**
```go
pocket.WithPrep(func(ctx context.Context, store pocket.StoreReader, input User) (any, error) {
    config, _ := store.Get(ctx, "config")
    return map[string]any{
        "user":   input,
        "config": config,
    }, nil
})
```

#### WithExec

Sets the Exec phase function.

```go
func WithExec(fn ExecFunc) NodeOption
func WithExec[In, Out any](fn func(context.Context, In) (Out, error)) NodeOption
```

**Example:**
```go
pocket.WithExec(func(ctx context.Context, data UserData) (Result, error) {
    return processUserData(data), nil
})
```

#### WithPost

Sets the Post phase function.

```go
func WithPost(fn PostFunc) NodeOption
func WithPost[In, Out any](fn func(context.Context, StoreWriter, In, any, Out) (Out, string, error)) NodeOption
```

**Example:**
```go
pocket.WithPost(func(ctx context.Context, store pocket.StoreWriter, 
    input User, prep any, result Result) (Result, string, error) {
    
    store.Set(ctx, "lastResult", result)
    
    if result.Success {
        return result, "success", nil
    }
    return result, "failure", nil
})
```

#### Lifecycle Hooks

```go
// Called on successful execution
func WithOnSuccess(fn func(context.Context, StoreWriter, any)) NodeOption

// Called on execution failure
func WithOnFailure(fn func(context.Context, StoreWriter, error)) NodeOption

// Always called after execution
func WithOnComplete(fn func(context.Context, StoreWriter)) NodeOption
```

#### Error Handling Options

```go
// Add retry with delay
func WithRetry(attempts int, delay time.Duration) NodeOption

// Add fallback on error
func WithFallback(fn func(context.Context, any, error) (any, error)) NodeOption
func WithFallback[In, Out any](fn func(context.Context, In, error) (Out, error)) NodeOption

// Add timeout
func WithTimeout(timeout time.Duration) NodeOption
```

## Store Operations

### NewStore

Creates a new store with optional configuration.

```go
func NewStore(opts ...StoreOption) Store
```

### StoreOption Functions

```go
// Set maximum number of entries (LRU eviction)
func WithMaxEntries(maxEntries int) StoreOption

// Set time-to-live for entries
func WithTTL(ttl time.Duration) StoreOption

// Set eviction callback
func WithEvictionCallback(fn func(key string, value any)) StoreOption
```

**Example:**
```go
store := pocket.NewStore(
    pocket.WithMaxEntries(1000),
    pocket.WithTTL(5 * time.Minute),
    pocket.WithEvictionCallback(func(key string, value any) {
        log.Printf("Evicted: %s", key)
    }),
)
```

### TypedStore

Type-safe store wrapper.

```go
// Create a typed store
func NewTypedStore[T any](store Store) TypedStore[T]

type TypedStore[T any] interface {
    Get(ctx context.Context, key string) (T, bool, error)
    Set(ctx context.Context, key string, value T) error
    Delete(ctx context.Context, key string) error
}
```

## Graph Building

### Builder API

Fluent API for constructing graphs.

```go
type Builder struct {
    // Internal fields
}

// Create a new builder
func NewBuilder(store Store) *Builder

// Add a node to the graph
func (b *Builder) Add(node Node) *Builder

// Connect two nodes
func (b *Builder) Connect(from, action, to string) *Builder

// Set the start node
func (b *Builder) Start(name string) *Builder

// Build the graph
func (b *Builder) Build() (*Graph, error)
```

**Example:**
```go
graph, err := pocket.NewBuilder(store).
    Add(validateNode).
    Add(processNode).
    Add(saveNode).
    Connect("validate", "success", "process").
    Connect("process", "success", "save").
    Start("validate").
    Build()
```

## Validation

### ValidateGraph

Validates type compatibility across connected nodes.

```go
func ValidateGraph(start Node) error
```

**Returns:**
- `nil` if all connections are type-compatible
- Error describing the first type mismatch found

**Example:**
```go
if err := pocket.ValidateGraph(startNode); err != nil {
    log.Fatalf("Invalid graph: %v", err)
}
```

## Concurrent Patterns

### FanOut

Process items in parallel.

```go
func FanOut[T, R any](ctx context.Context, processor Node, store Store, items []T) ([]R, error)
```

**Parameters:**
- `ctx`: Context for cancellation
- `processor`: Node to process each item
- `store`: Store for the operation
- `items`: Items to process

**Returns:**
- Results in the same order as inputs
- Error if any processing fails

### FanIn

Aggregate results from multiple sources.

```go
type FanIn struct {
    // Internal fields
}

func NewFanIn(aggregator Node, sources ...Node) *FanIn
func (f *FanIn) Run(ctx context.Context, store Store) (any, error)
```

### Pipeline

Execute nodes sequentially, passing output to next input.

```go
func Pipeline(ctx context.Context, nodes []Node, store Store, input any) (any, error)
```

### RunConcurrent

Execute multiple nodes concurrently.

```go
func RunConcurrent(ctx context.Context, nodes []Node, store Store) ([]any, error)
```

## Error Types

### Common Errors

```go
var (
    // No start node defined in graph
    ErrNoStartNode = errors.New("pocket: no start node defined")
    
    // Referenced node doesn't exist
    ErrNodeNotFound = errors.New("pocket: node not found")
    
    // Input type doesn't match expected type
    ErrInvalidInput = errors.New("pocket: invalid input type")
)
```

## Type Definitions

### Function Types

```go
// Prep phase function
type PrepFunc func(ctx context.Context, store StoreReader, input any) (prepResult any, err error)

// Exec phase function
type ExecFunc func(ctx context.Context, prepResult any) (execResult any, err error)

// Post phase function
type PostFunc func(ctx context.Context, store StoreWriter, input, prepResult, execResult any) (output any, next string, err error)
```

## Utility Functions

### Type Checking

```go
// Check if types are compatible
func IsTypeCompatible(outputType, inputType reflect.Type) bool
```

### Context Helpers

```go
// Add timeout to context
func WithTimeout(parent context.Context, timeout time.Duration) (context.Context, context.CancelFunc)

// Add cancellation to context
func WithCancel(parent context.Context) (context.Context, context.CancelFunc)
```

## Middleware Functions

See [Middleware Documentation](../advanced/MIDDLEWARE.md) for detailed middleware API.

```go
// Common middleware factories
func WithLogging(logger Logger) Middleware
func WithMetrics(collector MetricsCollector) Middleware
func WithRetry(attempts int, delay time.Duration) Middleware
func WithTimeout(timeout time.Duration) Middleware
```

## Batch Processing

See [Batch Processing Documentation](../patterns/BATCH_PROCESSING.md) for detailed batch API.

```go
// Map-reduce pattern
func MapReduce[T, R, A any](
    extract func(context.Context, Store) ([]T, error),
    mapper func(context.Context, T) (R, error),
    reducer func(context.Context, []R) (A, error),
    opts ...BatchOption,
) Node

// Process items in parallel
func ForEach[T any](
    extract func(context.Context, Store) ([]T, error),
    process func(context.Context, T) error,
    opts ...BatchOption,
) Node
```

## YAML Support

See [YAML Integration Documentation](../advanced/YAML_INTEGRATION.md) for detailed YAML API.

```go
// Load workflow from YAML
type Loader struct {
    // Internal fields
}

func NewLoader() *Loader
func (l *Loader) LoadFile(path string, store Store) (*Graph, error)
func (l *Loader) Load(data []byte, store Store) (*Graph, error)
func (l *Loader) RegisterHandler(name string, handler any) error
```

## Deprecated APIs

The following APIs are deprecated but still supported:

```go
// Deprecated: Use NewNode with generics instead
func TypedNode[In, Out any](name string, opts ...NodeOption) Node

// Deprecated: Use WithExec with generics instead
func ProcessorFunc(fn func(context.Context, any) (any, error)) Processor
```